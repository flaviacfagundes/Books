
### Dividir Para Conquistar (DC)

Os algoritmos Dividir para Conquistar são ==recursivos==. Para resolver um problema utilizando Dividir para Conquistar, você deve seguir dois passos:

1. Descubra o caso-base, que deve ser o caso mais simples possível.
2. Divida ou diminua o seu problema até que ele se torne o caso-base.

> **Algoritmo de Euclides** → Caso você encontre o maior quadrado que divide este segmento, ele será o maior quadrado que irá dividir toda a fazenda.

O algoritmo Dividir para Conquistar não é um simples algoritmo que você aplica em um problema, mas sim uma maneira de pensar sobre o problema.

>**Dica:** 
>Quando estiver escrevendo uma função de recursão que envolva um array, o caso-base será, muitas vexes, um array vazio ou um array com apenas um elemento.

- Haskell - Linguagem de programação funcional, baseada em recursão.


### Quicksort

O quicksort é um algoritmo de ordenação. Este algoritmo é muito mais rápido do que a ordenação por seleção e é muito utilizado na prática. O algoritmo quicksort também utiliza a estratégia DC.

- Por exemplo, vamos ordenar um array.

Arrays vazios ou com apenas um elemento serão o caso-base. Então podemos apenas retornar esse array.

![[Pasted image 20250810094155.png]]

Um array com dois elementos também é fácil de ordenar. Basta conferir se o primeiro elemento é menor do que o segundo. Caso não seja, eles são trocados de lugar.

E um array de três elementos? Lembre-se você está usando ==Dividir para Conquistar==, então você quer dividir esse problema até chegar no caso-base.

Portanto o funcionamento do quicksort segue esta lógica: **primeiro , escolha um elemento do array.** Esse elemento é chamado de ==pivô==. Assim, **encontre os elementos que são menores e maiores que o pivô**.

Isso é chamado de ==particionamento==. Deste modo você tem:

- Um subarray contendo todos os números menores do que o pivô
- O pivô
- Um subarray contendo todos os números maiores do que o pivô

Para ordenar os subarrays, é só utilizar o quicksort recursivamente em ambos os subarrays e então combinar os resultados, pois o caso -base do quicksort consegue ordenar array de dois 0 a 2 elementos. Com os subarrays estejam ordenados, poderá combina-los da seguinte forma:

`array(numeros menores) + [pivo] + array(numeros maiores)`

Assim, para ordenar um array de três elementos. Estes são os passos:

1. Escolha o pivô.
2. Particione o array em dois subarrays, separando-os entre elementos menores do que o pivô e elementos maiores do que o pivô.
3. Execute o quicksort recursivamente em ambos os subarrays.

![[Pasted image 20250810100211.png]]


> **Provas por Indução:**
> Representam uma maneira de mostrar que o seu algoritmo funciona. Cada prova por indução segue dois passos: caso-base e caso-indutivo. 
> 
> **- Imagine que quero provar que consigo subir uma escada.**
> No ==caso indutivo==, se minhas pernas estiverem em um degrau, poderei colocá-las no próximo degrau. Assim, se estiver no degrau 2, poderei subir para o degrau 3.
> Já para o ==caso-base==, falarei que minhas pernas estão no degrau 1 e que, portanto, sou capaz de subir a escada inteira, um degrau de cada vez.
> 
> **- No exemplo do array.**
> O algoritmo funciona para o caso-base: array de tamanho 0 e 1. No caso-indutivo, da mesma forma que o quicksort funciona para um array de tamanho 1, ele também funciona para os de tamanho 2, 3, 4 e assim por diante. Assim podemos dizer que funciona para todos os tamanhos de array.


### Caso Médio Versus Pior Caso

- O caso médio é quando você divide a busca pela metade (tempo de execução *O(n log n)*)
- O pior caso é quando você precisa passar por todos os itens (tempo de execução *O(n)*)

O algoritmo quicksort é um dos mais rápidos algoritmos de ordenação que existem, sendo um ótimo exemplo de ==Dividir para Conquistar(DC)==.


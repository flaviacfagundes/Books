
Um *algoritmo* é um conjunto de instruções que realizam uma tarefa.


### Pesquisa Binária

A pesquisa binária é um algoritmo. Sua entrada é uma ==lista ordenada== de elementos. Se o elemento que você está buscando está na lista, a pesquisa binária retorna a sua localização. Caso contrário, a pesquisa binária retorna `None / Null`.

A pesquisa simples é quando se tem uma lista de *n* números e, no pior dos casos, você precisa de *n* etapas para conseguir encontrar o item desejado na lista. Já na pesquisa binária você precisa de `log2 n` ou seja, você elimina metade dos números a cada nova tentativa.

Por exemplo, se precisar procurar uma palavra em um dicionário com 240.00 palavras. Se a palavra que você precisa consultar for a última palavra, você precisaria de 240.00 etapas para poder encontra-la, com a ==pesquisa simples==. 

Já com a ==pesquisa binária== apenas 18 etapas são necessárias, pois você vai quebrando cada pesquisa pela metade. 240.00 → 120.000 → 60.000 → 30.000 → 15.000 → 7.500 → 3.750 → 1.875 → 938 → 469 → 235 → 118 → 59 → 30 → 15 → 8 → 4 → 2 → 1.


> **Logaritmos**
> A expressão log10 100, diz: "*Quantos 10s conseguimos multiplicar para chagar a 100?*"
> 	A resposta é 2, pois 10 * 10 = 100.
> log 1024 == 10, porque 2 elevado a 10 é igual a 1024.
> ==log = log2== 

A pesquisa binária só funciona quando a sua lista está ordenada.


### Tempo de Execução

Quando o número máximo de tentativas é igual ao tamanho da lista, é chamado de ==tempo linear==, isso ocorre na pesquisa simples. Já a pesquisa binária é executada em ==tempo logarítmico==.


### Notação Big O

A notação Big O é uma notação especial que diz o quão rápido é um algoritmo. O tempo de execução na notação Big O é O(n), sendo *n* o número de operações. E é chamado de Big O, porque coloca-se um "*grande O*" na frente do número de operações.

> A notação Big O não fornece o tempo em segundos, ela permite que você compare o número de operações. Ela informa o quão rapidamente um algoritmo cresce.
> **A rapidez de um algoritmo não é medida em segundos.**

- Para a pesquisa simples é ==O(n)==
- Para a pesquisa binária é ==O(log n)==

A notação Big O leva em conta a pior das hipóteses. Então pode-se dizer que, para o pior caso, você analisou cada item da lista. Esse é o tempo O(n). É uma garantia - você sabe que a pesquisa simples nunca terá tempo de execução mais lento que O(n).

**O tempo de execução de uma algoritmo é medido por meio de seu crescimento.**

Exemplos comuns de tempo de execução Big O:

- O(log n), também conhecido como tempo logarítmico. Exemplo: pesquisa binária
- O(n), conhecido como tempo linear. Exemplo: pesquisa simples
- O(n * log n). Exemplo: um algoritmo rápido de ordenação, como a *ordenação quicksort*
- O(n²). Exemplo: um algoritmo lento de ordenação, como a *ordenação por seleção*
- O(n!), conhecido como tempo fatorial. Exemplo: um algoritmo bastante lento, como o do *caixeiro-viajante*


### Caixeiro-Viajante

Ele é um problema famoso da ciência da computação, pois seu crescimento é apavorante e possui um tempo de execução muito ruim.

- Você tem um caixeiro-viajante.
- O caixeiro precisa ir a cinco cidades.
- Ele soma a distância total e escolhe o caminho de menor distância.
- Existem 120 operações para resolver o problema das 5 cidades.
	- Para 6 cidades são 720 operações.
	- Para 7 cidades são 5.050 operações.

Esse algoritmo (*O(n!)*) consome muitas operações, exceto para casos envolvendo números pequenos. **O problema é que não existe um algoritmo mais rápido para esse problema**.

> Ler sobre: Árvores binárias de busca


